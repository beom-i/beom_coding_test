# [Silver V] 폴리오미노 - 1343 

[문제 링크](https://www.acmicpc.net/problem/1343) 

### 성능 요약

메모리: 2080 KB, 시간: 0 ms

### 분류

그리디 알고리즘, 구현

### 문제 설명

<p>민식이는 다음과 같은 폴리오미노 2개를 무한개만큼 가지고 있다. AAAA와 BB</p>

<p>이제 '.'와 'X'로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 'X'를 모두 폴리오미노로 덮으려고 한다. 이때, '.'는 폴리오미노로 덮으면 안 된다.</p>

<p>폴리오미노로 모두 덮은 보드판을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 보드판이 주어진다. 보드판의 크기는 최대 50이다.</p>

### 출력 

 <p>첫째 줄에 사전순으로 가장 앞서는 답을 출력한다. 만약 덮을 수 없으면 -1을 출력한다.</p>


### 배울 것
1) 그리디 같은 경우나 문제를 풀 때 언제를 기준으로 변하는지, 언제를 기준으로제한이되는지 판단해야 하고 여기선 .을 기준으로 카운트를 세고 하는 방법으로 해결했음
2) ostringstream oss을 사용하는 법
   1) oss는 oss<<1을 사용해서 스트림에 꽉 채워놓음 cout<<oss.str()을 사용하면 지금까지 oss로 빼둔 것이 생성됨
   2) 중간에 cout<<1을 하면 쌓아놓은 녀석들이 출력되는 것이 아니라 1만 출력되고 끝남
3) 특정 문자열을 반복해서 출력하는 방법 "AAA"*2를 사용 X => string(count,'A');을 사용해서 반복할 수 있음 이때,A는 문자열이 아닌 문자여야 합니다.
